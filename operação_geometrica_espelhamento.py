# -*- coding: utf-8 -*-
"""Operação geometrica Espelhamento

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15qRXXwKnCZwDyU6EjeBsWGNkgdQhe1cF
"""

import cv2 as cv
from PIL import Image, ImageDraw
import numpy as np
import random
import requests
import io
from google.colab.patches import cv2_imshow


#url_imagem = "https://img.freepik.com/fotos-gratis/seta-vermelha-com-copia-espaco_23-2148488357.jpg"
url_imagem = "https://img.freepik.com/vetores-gratis/modelo-de-adesivo-com-uma-unica-casa-isolada_1308-64529.jpg"

# Fazendo o download da imagem
resposta = requests.get(url_imagem)

nome_imagem = "carro.jpg"

if resposta.status_code == 200:
    # Usando BytesIO para carregar a imagem diretamente em memória
    imagem = Image.open(io.BytesIO(resposta.content))

    # Pegando as proporções da imagem original
    largura_original, altura_original = imagem.size

def operacao_reflexao():
    print("\nOperação de reflexão/espelhamento!")

    # Aloca memória para a imagem e carrega os dados dos pixels
    imagem_pixels = imagem.load()

    # Cria uma nova imagem do tipo RGB com o tamanho da imagem que foi "aberta"
    # Uma nova pagina em "branco" com um modelo RGB definido
    imagem_espelhada = Image.new("RGB", imagem.size)

    # Cria um objeto que pode ser usado para desenhar a imagem dada
    # Permite que eu posso modificar aquela imagem "desenhar nela"
    # Vai ser a matriz que vai guardar o resultado da reflexão
    draw = ImageDraw.Draw(imagem_espelhada)

    print(20*"---")
    print("Digite o número do espelhamento desejado: ")
    print(20*"---")
    print("1. Espelhamento horizontal")
    print("2. Espelhamento vertical")
    espelhamento_escolhido = int(input(''))

    if espelhamento_escolhido == 1:
        print("Espelhamento horizontal escolhido!")

        # Trabalha nas linhas da imagem
        for i in range(imagem_espelhada.width):
            for j in range(imagem_espelhada.height):
                # Pega o Ultimo pixel
                # Indo ate o pixel inicial em cada rotação
                xp = imagem.width - i - 1
                # Vai fazer o processo de "troca" colocando o ultimo (n-1, 0) pixel na posição inicial (0 ,0)
                # fazendo esse processo andando toda a linha.
                draw.point((i, j), imagem_pixels[xp, j])

        imagem_espelhada.save(f"{nome_imagem}_imagem_espelhada_horizontal.png")
    # Trabalha nas colunas da imagem
    elif espelhamento_escolhido == 2:
        print("Espelhamento vertical escolhido!")

        for i in range(imagem_espelhada.width):
            for j in range(imagem_espelhada.height):
                jp = imagem.height - j- 1
                draw.point((i, j), imagem_pixels[i, jp])

        imagem_espelhada.save(f"{nome_imagem}_imagem_espelhada_vertical.png")

    else:
        print("Número inválido. Tente novamente!")
        operacao_reflexao()

    # Convertendo a imagem PIL para formato OpenCV
    imagem_espelhada_cv = np.array(imagem_espelhada)
    imagem_espelhada_cv = cv.cvtColor(imagem_espelhada_cv, cv.COLOR_RGB2BGR)

    # Exibindo a imagem espelhada
    cv2_imshow(imagem_espelhada_cv)

    print('imagem_espelhada.height: ', imagem_espelhada.height)
    print('imagem_espelhada.width: ', imagem_espelhada.width)

def menu():
    operacao_reflexao()
menu()